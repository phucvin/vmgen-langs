\ comments start with "\ " (note that "\E" is not a comment)

\ stack definitions:
\E stack data-stack sp Cell

\ stack prefix definitions
\E inst-stream stack-prefix #

\ type prefix definitions:
\E s" long"   single data-stack type-prefix i
\E s" char *" single data-stack type-prefix a
\E s" Inst *" single data-stack type-prefix target

\ simple VM instructions:
add ( i1 i2 -- i )
i = i1+i2;

sub ( i1 i2 -- i )
i = i1-i2;

lt ( i1 i2 -- i )
i = i1<i2;

lit ( #i -- i )

branch ( #target -- )
SET_IP(target);

zbranch ( #target i -- )
if (i==0) {
  SET_IP(target);
  INST_TAIL;
}

\  The stack is organized as follows:
\  The stack grows downwards; a stack usually looks like this:

\  higher addresses
\  --------------------- bottom of stack
\     locals of main
\     return address (points to VM code after call)
\  +->oldfp (NULL)
\  |  intermediate results (e.g., 1 for a call like 1+foo(...))
\  |  arguments passed to the called function
\  |  locals of the called function
\  |  return address (points to VM code after call)
\  +--oldfp                <-- fp
\     intermediate results <-- sp
\  ---------------------- top of stack
\  lower addresses

\ The following VM instructions also explicitly reference sp and
\ therefore may have to do something about spTOS caching.

call ( #target #iadjust -- targetret aoldfp )
/* IF_spTOS(sp[2] = spTOS);*/ /* unnecessary; vmgen inserts a flush anyway */
targetret = IP;
SET_IP(target);
aoldfp = fp;
sp = (Cell *)(((char *)sp)+iadjust);
fp = (char *)sp;
/* IF_spTOS(spTOS = sp[0]); */ /* dead, thus unnecessary; vmgen copies aoldfp there */

return ( #iadjust target afp i1 -- i2 )
/* IF_spTOS(sp[-2] = spTOS); */ /* unnecessary; that stack item is dead */
SET_IP(target);
sp = (Cell *)(((char *)sp)+iadjust);
fp = afp;
i2=i1;
/* IF_spTOS(spTOS = sp[0]); */ /* dead, thus unnecessary; vmgen copies i2 there */

\ loadlocal and storelocal access stack items below spTOS, so we can
\ ignore spTOS caching.

loadlocal ( #ioffset -- i )
vm_Cell2i(*(Cell *)(fp+ioffset),i);

end ( i -- )
/* SUPER_END would increment the next BB count (because IP points there);
   this would be a problem if there is no following BB.
   Instead, we do the following to add an end point for the current BB: */
#ifdef VM_PROFILING
block_insert(IP); /* we also do this at compile time, so this is unnecessary */
#endif
return i;

include(vm-super.vmg)
